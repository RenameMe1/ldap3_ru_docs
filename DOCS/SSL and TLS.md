---
tags:
  - ldap3
  - python
---
# SSL and TLS

Вы можете использовать базовую SSL аутентификацию используя параметр `use_ssl` в объекте [[Server]], вы также должны обозначить `port` (636 по умолчанию для безопасного ldap).

``` python

# Определяет безопасный LDAP сервер
server = Server('servername', port=636, use_ssl=True) 

```

Для запуска TLS подключения на уже созданном `_clear` подключении

``` python

connection.start_tls()

```

В некоторых более старых версиях (до 2.7.9) Python интерпретатора отсутствовала возможность проверки сертификата сервера на соответствие DNS-имени сервера. Это потенциальная дыра безопасности, потому-что сервер может предоставить сертификат выданный для другого хоста. [[ldap3]] включает в себя резервную версию этой возможности, перенесенную из версии интерпретатора Python 3.4.3. Если вы хотите поддерживать свое приложение в актуальном состоянии с помощью функции проверки имени хоста последней версии Python, вы можете установить пакет backports.ssl_match_hostname из pypi. Библиотека [[ldap3]] обнаружит и будет использовать ее вместо включенного статического резервного порта.

## Объект TLS

Вы можете катализировать серверный TLS объект используя ссылки на ключи, сертификаты и CA. Он включает все атрибуты необходимые для безопасного подключения через ssl сокет.

- local_private_key_file: файл с приватным ключом клиента.
- local_certificate_file: сертификат сервера.
- validate: определяет если сертификат сервера должен быть проверен, значения могут быть: `CERT_NONE` (сертификат игнорируется), `CERT_OPTIONAL` (нет необходимости в сертификате, но проверяется если предоставить) и `CERT_REQUIRED` (необходим и проверяется).
- version: `SSL` или `TLS` версии для использования, могут быть одним из следующих:
`SSLv2, SSLv3, SSLv23, TLSv1` (Согласно Python 3.3. Список версий может отличаться в других версиях Python)
- ca_certs_file: Файл содержащий сертификаты сертифицирующих органов
- ciphers: Строка, которая указывает какие cippers должны быть использованы. Он работает на последних Python интерпретаторах, которые допускают изменение cipher в SSLContext или в методе `wrap_socket()`. Он игнорируется в более старых версиях.

Tls объект использует ssl модуль стандартной библиотеки Python с функциями дополнительной проверки, которые отсутствую в стандартной библиотеке Python 2.

Необходимые константы определены в пакете ssl.

Если вы не используете указанный Tls объект и установили `use_ssl=True` в определении объекта [[Server]], по стандарту будет использоваться Tls объект, у него нет файлов сертификата, используете `ssl.PROTOCOL_SSLv23` (Если доступно в вашем Python интерпретаторе) и не выполняйте проверку серверного сертификата. Это рекомендованного при установке `validate=ssl.CERT_REQUIRED` для проверки сертификата сервера. Пример:

``` python

tls = Tls(
    local_private_key_file='client_private_key.pem',
    local_certificate_file='client_cert.pem',
    validate=ssl.CERT_REQUIRED,
    version=ssl.PROTOCOL_TLSv1,
    ca_certs_file='ca_certs.b64'
    )

```

## SSLContext

Вы можете использовать SSLContext работая с Python 3.4 или новее.

Использование ssl.SSLContext делает TLS операцию более гибким, Он интегрируется с общедоступной системой центров сертификации и так же гарантирует что есть "разумные" настройки безопасности по умолчанию при использования уровня TLS. Он так же позволяет указать файловой системе путь содержащий CA файл или даже передать данные сертификата "на лету".

При определении Tls объекта у вас есть следующие дополнительные параметры:

- ca_certs_file: обычно ссылка на цепь сертификатов органов сертифицирования
- ca_certs_path: ссылка к пути содержащему сертификаты органов сертифицирования (переработано, как и ожидалось OpenSSL'ем)
- ca_certs_data: данные CA сертификата хранящиеся в памяти

Если вы оставите все эти параметры как `None` SSLContext будет использовать общедоступное системное хранилище сертификатов (ssl путь на linux, CA хранилище на Windows)

Если SSLContext не доступен, библиотека вернет к механизму обернутого сокета ssl ( ssl wrapped socket mechanism) 

## SASL

Три SASL механизма сейчас реализовано в библиотеке [[ldap3]]: `EXTERNAL`, `DIGEST-MD5` и `GSSAPI` (Kerberos, через пакет gssapi). Несмотря на то, что 'DIGEST-MD5' **устарел** и оставлен в истории (RFC6331, July 2011) из-за того, что он **ненадежный и неподходящий для использования в протоколах** (как указано RFC) я разработал фазу аутентификации протокола, потому что он до сих пор используется в серверах LDAP.

## External

Вы можете использовать `EXTERNAL` механизм, когда вы на безопасном (TLS) канале. Вы можете предоставить строку идентификатора авторизации в `sasl_credentials` или позволить серверу довериться учетным данным предоставленным при создании безопасного канала:

``` python

tls = Tls(
    local_private_key_file='key.pem',
    local_certificate_file= cert.pem',
    validate=ssl.CERT_REQUIRED,
    version=ssl.PROTOCOL_TLSv1,
    ca_certs_file='cacert.b64'
    )
server = Server(
    host=test_server,
    port=test_port_ssl,
    use_ssl=True,
    tls=tls
    )
connection = Connection(
    server,
    auto_bind=True,
    version=3,
    client_strategy=test_strategy,
    authentication=SASL,
    sasl_mechanism= EXTERNAL',
    sasl_credentials= username'
    )

```

Если операция `bind` не работает с:

``` python

sasl_credentials = None

```

Вы можете попробовать:

``` python 

sasl_credentials=''

```
## Digest-MD5

Для использования DIGEST-MD5 вы должны передать кортежей из 4 или 5 значений как `sasl_credentioals` (realm, user, password, authz_id, enable_singins). Вы можете передать `None` для 'realm', 'authz_id', и 'enable_singing' если не используется:

``` python

server = Server(
    host=test_server,
    port=test_port
    )
connection = Connection(
    server,
    auto_bind=True,
    version=3,
    client_strategy=test_strategy,
    authentication=SASL,
    sasl_mechanism='DIGEST-MD5',
    sasl_credentials=(
        None,
        'username',
        'password',
        None,
        'sign'
        )
    )

```

Имя пользователя не обязательно должно быть записью LDAP, но оно может быть любым распознаваемым сервером идентификатором (например почта, имя участника и т.д).
Если вы передаете `None` в качестве 'realm', то будет использован стандартный realm LDAP сервера. 

`enable_signing` - не обязательный аргумент, который подходит только для Digest-MD5 аутентификации. Этот аргумент включает или выключает подпись (Защита целостности) при выполнении LDAP запросов. Подпись LDAP это способ предотвратить повторные атаки без шифрования LDAP трафика. Microsoft публично рекомендует принудительно использовать LDAP подпись при общении с Active Directory сервером:

https://support.microsoft.com/en-us/help/4520412/2020-ldap-channel-binding-and-ldap-signing-requirements-for-windows

- При `enable_signing` установленном на `sign`, Запросы LDAP подписываются и подпись LDAP ответа проверяется.
- При `enable_signing` установлено как любое другое значение или не установлено, LDAP запросы не подписываются.

Также, DIGEST-MD5 аутентификация с шифрованием в дополнение к защите целостности (`qop=auth-conf`) не поддерживается [[ldap3]].

**Использование DIGEST-MD5 без подписи LDAP считается устаревшим и не должно использоваться.**