---
tags:
  - ldap3
  - python
---
|{Переведена v2.9.1}

Руководство: Введение в [[ldap3]] .
|https://ldap3.readthedocs.io/en/latest/tutorial_intro.html#|

    Заметка .
    . В этом руководстве вы получите доступ к публичной демонстрационной версии 
    |https://www.freeipa.org/ | ,доступной по |https://ipa.demo1.freeipa.org| 
    (Вы должны довериться его сертификату при первой авторизации). FreeIPA это 
    полнофункциональное решение по управлению идентификацией, 
    но для цели этого руководства нам итересен только его LDAP сервер. Обратите
    внимание, что демонстрационный сервер переодически очищается, как описано
    в FreeIPA demo wiki page |https://www.freeipa.org/page/Demo|.

    Предупреждение .
    . Если вы получаете исключение`LDAPSocketReceiveError: error receiving data`, то 
    сервер может внезапно закрыть подключение. Вы можете легко переоткрыть его
    с помощью метода 
    | conn.bind()

. Даже если вы реально ничего не знаете о LDAP. После прочтения этого руководства
вы сможете получить доступ к LDAP совместимому серверу. 

Чем не является LDAP .
|https://ldap3.readthedocs.io/en/latest/tutorial_intro.html#what-ldap-is-not|

  . Я бы хотел быть уверенным что вы осведомлены о том, чем не является LDAP

    * LDAP - не сервер
    * LDAP - не база данных
    * LDAP - не сетевой сервис
    * LDAP - не сетевое устройство
    * LDAP - не логин/пароль репозиторий
    * LDAP - не аутентификационная процедура
    * LDAP - не конкретный продукт с открытым или закрытым исходным кодом

  . Важно знать чем LDAP не является, потому что люди обычно называют "LDAP" 
  своеобразной частью того, что они используют в `Lightweight Directory`` 
  `Access Protocol` LDAP это протокол как и другие "заканчивающие на P" 
  слова в экосистеме интернета (HTTP, FTP, TCP, IP, …) это набор правил 
  которым ты должен следовать при общении с внешним сервером/базой данных/
  сервисом/устройством/процедурой/репозиторием/продуктом 
  (Все что было в списке выше)

  . Управление данными в LDAP осуществляется через ключ/значение(я) группированные
  пары в иерархичной структуре. Эта структура называется 
  |DIT (Directory Information Tree / Дерево информации о каталоге)|. LDAP не 
  указывает как данные на самом деле хранятся в DIT и не указывает как 
  пользователи авторизовываются для доступа к нему. Есть только немного типов
  данных которые каждый LDAP сервер может распознавать (Некоторые из них очень
  старые и не используется более). LDAP версии 3 также расширяемый протокол, 
  это означает, что поставщик (вендор) может добавлять функции не указанные
  в LDAP спецификации (используя Controls и расширения). Любой LDAP сервер
  полагается на `схему`, чтобы знать, какие типы данных, атрибуты и объекты он
  понимает. Часть схемы стандартная (определена в самом протоколе), но каждый 
  поставщик (вендор) может добавлять атрибуты и объекты для определенных целей.
  Схема может также быть расширена системным администратором, разработчиком 
  и конечным пользователем LDAP сервера. 

  . Любопытно что "расширение схем" не определенны в протоколе LDAP, поэтому
  каждый поставщик (вендор) разработал различные методы добавления объектов,
  атрибутов и дополнительных правил в схему.

  . Являясь протоколом, LDAP не привязан к каким-либо определенным продуктам 
  и это описано в наборе |RFCs (Request for comments, the official|
  |rules of the Internet ecosystem / Запрос на отызы, официальные правила|
  |экосистемы интернета)|. `Version 3` задокументированная в RFC4510 (и последующих
  RFCs) выпущенная в Июне 2006 - Последняя версия этих правил. 

Краткая история LDAP .
|https://ldap3.readthedocs.io/en/latest/tutorial_intro.html#a-brief-history-of-ldap|

. Вы можете задаться вопросом, почему `"Lightweight"` LDAP. Он предок |DAP (Directory|
|Acess Protocol / Директория протокола доступа)| разработанного в 1980 международный 
комитет телефонии и телеграфии (CCITT ныне ITU-T - International Committee 
for Telephone and Telegraphy. Почтенная организация, среди прочих, давшая нам - факс,
и протоколы которые мы использовали на модемах в эпоху предшествовавшую 
появлению интернета). Даже если предназначение DAP состояло в стандартизации
доступа к каталогу сервисов (например телефонных справочников) он был очень 
тяжелым и труднореализуемым протоколом (для компонентов клиентов и серверов)
и не был доступен через TCP/IP. В 1993 году университетом Мичигана (University of Michigan)
был изобретен упрощенный протокол доступа, действующий как шлюз в мир DAP.
Впоследствии поставщики (вендоры) разработали продукты, которые могли понимать 
LDAP напрямую и шлюз к DAP был вскоре удален. LDAP v3 был впервые задокументирован
в 1997 году, а его спецификации были исправлены в 2006. Эти поздние спецификации
строго соблюдаются библиотекой [[ldap3]].


Unicode везде .
|https://ldap3.readthedocs.io/en/latest/tutorial_intro.html#unicode-everywhere|

. LDAP протокол определяет имена атрибутов и их строковые значения (обычно в 
Directory string LDAP syntax) которые должны храниться в версии Unicode 3.2 
с UTF-8 кодированием. Есть некоторые ограничения в определении имен атрибутов,
должны использоваться только ASCII символы (верхний или нижний регистр), цифры
и сисволы дефиса (но не как первый символ).

. `Unicode` это стандарт для описания десятков тысяч печатных (и даже невидимых)
символов, но что передается по проводам когда ты взаимодействуешь с LDAP
сервером - только старые, простые байты (С значениями как обычно в диапозоне 
от 0 до 255), так UTF-8 кодирование необходимо при общении с LDAP сервером 
для преобразования Unicode симоволов в допустимое байтовое (или мультибайтовое)
представление. По этой причине когда отправляется строковое значнение в 
любой LDAP операции, оно должна быть преобразовано в UTF-8 кодировку. 
Ваша среда может иметь (и верятно имеет) другие стандарнтые кодировки, 
так библиотека [[ldap3]] будет пытаться преобразовывать из ваших стандартных 
кодировок в кодировку UTF-8 за вас, но вы можете установить разные входящие 
кодировки с помощью функции 

| set_config_parameter('DEFAULT_ENCODING', 'my_encoding')

в библиотеке [[ldap3]]. Строковое значнеие возвращенное операцией поиска LDAP всегда
закодирована и UTF-8. Это не применряется к прочим бинарным форматам, как `Octect String`
для этого должна использоваться другая кодировка. 

Пакет [[ldap3]] .
|https://ldap3.readthedocs.io/en/latest/tutorial_intro.html#the-ldap3-package|

. [[ldap3]] это полностью совместимая с LDAP v3 клиентская библиотека, соблюдающая
официальный RFCs выпущенный в Июне 2006 года. Она написана с нуля для совместимости
с PYTHON 2, PYTHON 3 и может быть использована на любой машине где PYTHON может
получить доступ к сети через стандартную бибилотеку.

. Скорее всего вы обнаружите [[ldap3]] пакет уже установленным
(или его можно установить из вашего локального пакетного менеджера) на вашу 
машину, просто попробуйте `import ldap3` в вашей PYTHON консоли. Если вы получаете
`ImportError` вам необходимо установить пакет из PyPI через pip, в обычных случаях 

| pip install ldap3

    Предупреждение .
    . Если pip сетует на сертификат, вы должны определить путь к PyPI CA 
    сертификату с параметром `--cert`

    | pip isntall ldap3 --cert /path/to/the/DigiCert_High_Assurance_EV_Root_CA.pem

. Вы так же можете загрузить исходный код из |https://github.com/cannatag/ldap3|
и установить его 

| pip setup.py install 

. Необходимый для [[ldap3]] пакет - `pyasn1` (и он будет установлен, если его еще нет).
Этот пакет используется для общения с сервером по сети. По стандарту [[ldap3]] 
использует pyasn1 пакет только когда отправляет данные на сервер. Данные 
полученные из сервера декодируются внутренним ASN1 декодером, гараздо быстрее 
чем pyasn1 декодером

Доступ к серверу LDAP .
|https://ldap3.readthedocs.io/en/latest/tutorial_intro.html#accessing-an-ldap-server|

. Использовать [[ldap3]] просто: вы определяете объект [[Server]] (сервер) и 
объект [[Connection|connection]] (соединение). Затем вы даете команды [[Connection|connection]] (соединению).
Сервер может иметь любое число активных соединений с такой же или разными стратегиями
коммуникации (communication strategy).

. Все импортируемые объекты доступны в [[ldap3]] пространстве (namespace). Меньшее что 
вам необходимо - импортировать объекты Sever (сервер) и [[Connection|connection]] (подключение),
и любую дополнительную константу, которую вы будете использовать в вашем диалоге 
с LDAP (Константы определяются в верхнем регистре) 

| from ldap3 import Server, Connection, ALL 

.  Конкретные исключения [[ldap3]] определяются в пакете |ldap3.core.exceptions|

    Заметка .
    . Больше pythonic LDAP: LDAP операции выглядят неуклюже и сложны в использовании потому-что
    они отражают старые идеи о том, что длительные операции должны быть выполнены на клиенте не
    перегружая и не загромождая сервер ненужной работой. [[ldap3]] включает в себя полностью функциональный
    уровень абстракции (Abstract Layer) которые дает вам взаимодействовать с DIT современным и 
    pythonic способом. С уровнем абстракции вам не нужно напрямую создавать какую-либо LDAP 
    операцию вовсе.

. Аутентификационные операции в LDAP протоколе называются `Bind`.  Bind может быть выполнен тремя
различными способами: 
    * анонимный, 
    * простой парольный 
    * SASL (Simple Authentication and Security Layer, допускающий больший набор аутентификационных механизмов). 
Вы можете рассматировать анонимный Bind как публичном доступе к LDAP серверу где нет 
предоставленных учетных данных и сервер применяет стандарнтые правила доступа. C простым 
парольным Bind и SASL Bing вы пердоставляете учетные данные, которые LDAP сервер использует 
для определения вашего авторизационного уровня. Опять же, держите в голове, что стандарт LDAP
не определяет конкретные правила доступа, так каждый поставщик (вендор) LDAP сервера разработал
свой различный метод авторизации пользователей для доступа к хранилищу данных в DIT.

. [[ldap3]] позволяет вам выбрать метод, который клиент будет использовать для подключения к серверу 
параметром |client_strategy| в объекте [[Connection|connection]]. Есть четыре стратегии, которые могут быть 
использованы для создания подключения: SYNC (синхронная), ASYNC (асинзронная),
RESTARTABLE (перезапускаемая) and REUSABLE (переиспользуемая). Как основное правило, в синхронных
стратегиях (SYNC, RESTARTABLE) все LDAP операции возвращают логический тип: |True| если 
они удачны, |False| если не удачны; в асинхронных стратегиях (ASYNC, RESUABLE) все LDAP 
операции () возвращают число, message_id (идентификатор сообщения) запроса. При асинронных 
стратегиях вы можете отправить несколько запросов без ожидания ответов, а затем получить
кадый ответ с помощью метода |get_response(message_id)| объекта [[Connection|connection]] по мере необходимости.
[[ldap3]] будет возвращать исключение если ответ еще не получен после определенного времени. В 
методе |get_response()| значение таймаута может быть установлено с помощью параметра |timeout|
числом секунд для ожидания появления ответа (по стандарту 10 секунд). Если вы используете 
|get_request=True| в параметре метода |get_response()| вы также получаете словарь запроса обратно.

. Асинхронные стратегии потокобезопасны и полезны с медленными серверами или когда у вас много 
запросов с тем же объектом [[Connection|connection]] в нескольких потоках. Обычно вы будете использовать
только синхронные стратегии. 

. |LDIF| стратегия используется для создания потоков LDIF-CHANGEs (LDIF расшифровывается как 
LDAP Data Interchange Format, текстовый стандарт используемый для описания изменений 
выполненных LDAP операциями). MOCK_SYNC и MOCK_ASYNC стратегии могут быть использованы для 
имитирования фальшивого LDAP сервера для тестов ваших приложений без необходимости в 
реальном LDAP сервере.

    Заметка .
    . В этом руководстве вы будете использовать стандартные SYNC коммуникационные стратегии. 
    Если вы продолжаете терять подключение к серверу, вы можете использовать RESTARTABLE
    стратегию коммуникации, которая пытается переподключаться и переотправлять операции когда 
    соединение к серверу потеряно.

. Давайте начнем с доступа к серверу при помощи анонимногно bing:

| from ldap3 import Server, Connection
|
| server == Server('ipa.demo1.freeipa.org')
| conn = Connection(server)
| conn.bind()
| # True

или короче:

| from ldap3 import Connection
|
| conn = Connection('ipa.demo1.freeipa.org, auto_bind=True')

Вряд ли это может быть проще, чем сейчас. Параметр |auto_bind=True| принуждает выполнить 
операцию Bind после создания объекта [[Connection|connection]]. Сейчас у вас полностью рабочая открытая
анонимная сессия, привязанная к серверу с помощью синхронной коммуникационной стратегии:

| print(conn)
| # ldap://ipa.demo1.freeipa.org:389 - cleartext - user: None - bound - open - <local: 192.168.1.101:49813 - remote: 209.132.178.99:389> -
| tls not started - listening - SyncStrategy - internal decoder

. Используя |print(conn)| вы спрашиваете подключение его статус и получаете обратно информацию:

    * ldap://ipa.demo1.freeipa.org:389 - 
    * cleartext -
    * user: None - 
    * bound -
    * open - 
    * <local: 192.168.1.101:51038 - remote: 23.20.46.132:389> -
    * tls not started - 
    * listening - 
    * SyncStrategy - 
    * internal decoder -

    Заметка .
    . Представление объекта: библиотека [[ldap3]] использую следующие правила предназначения объекта:
    когда вы используете |str()| вы получаете обратно информацию о статусе объекта в 
    человекочитаемом формате, когда вы используете repr() вы получаете назад строку, которую
    можете использовать ее в Python консоли для пересоздания объекта. |print()| всегда 
    возвращает |str()| представление. При вводе в командную строку |>>>| всегда возвращает 
    |repr()| представление которое может быть использовано для пересоздания объекта в вашем коде.

. Если вы запросите представление |repr()| объекта [[Connection|connection]] вы можете получить фрагмент Python 
кода 

| >>> conn
| Connection(server=Server(host='ipa.demo1.freeipa.org', port=389, use_ssl=False, get_info='NO_INFO'), auto_bind='NONE',
| version=3, authentication='ANONYMOUS', client_strategy='SYNC', auto_referrals=True, check_names=True, read_only=False,
| lazy=False, raise_exceptions=False, fast_decoder=True)

. Если вы просто скопируете и вставите представление объекта в |>>>| интерактивную консоль
вы можете создать экземпляр нового объекта схожего с оригинальным. Это полезно при экспериментах
в интерактивной консоли и работает для большинства объектов библиотеки [[ldap3]]